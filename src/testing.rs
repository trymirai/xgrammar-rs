use autocxx::prelude::*;

use crate::{DLTensor, cxx_utils, ffi};

/// Convert a function call schema to EBNF grammar in Qwen XML style.
pub fn qwen_xml_tool_calling_to_ebnf(schema_json: &str) -> String {
    let schema_cxx = ffi::make_string(schema_json);
    cxx_utils::qwen_xml_tool_calling_to_ebnf(&schema_cxx).to_string()
}

/// Get the ids of the rejected tokens from the bitmask. Mainly for debug purposes.
///
/// # Parameters
/// - `bitmask`: The rejected token bitmask. Should be generated by allocate_token_bitmask
///   and filled by fill_next_token_bitmask.
/// - `vocab_size`: The size of the vocabulary.
/// - `index`: The batch index of the bitmask (default: 0).
///
/// # Returns
/// A boxed slice of rejected token ids.
pub fn get_masked_tokens_from_bitmask(
    bitmask: &DLTensor,
    vocab_size: i32,
    index: i32,
) -> Box<[i32]> {
    unsafe {
        let result = ffi::cxx_utils::get_masked_tokens_from_bitmask(
            bitmask as *const _,
            vocab_size,
            index,
        );
        result.iter().copied().collect()
    }
}

/// Check if the bitmask is a single token bitmask.
///
/// # Parameters
/// - `bitmask`: The bitmask to check.
/// - `vocab_size`: The size of the vocabulary.
/// - `index`: The index of the bitmask (default: 0).
///
/// # Returns
/// A tuple of (is_single_token, token_id). token_id is -1 if not a single token.
pub fn is_single_token_bitmask(
    bitmask: &DLTensor,
    vocab_size: i32,
    index: i32,
) -> (bool, i32) {
    unsafe {
        let result = ffi::cxx_utils::is_single_token_bitmask(
            bitmask as *const _,
            vocab_size,
            index,
        )
        .within_unique_ptr();
        (result.get_is_single(), result.get_token_id())
    }
}
